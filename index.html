<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>3D Shooter + Bauen</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute; top: 10px; left: 10px;
            color: white; font-family: Arial; font-size: 16px;
            background: rgba(0,0,0,0.4); padding: 8px;
        }
    </style>
</head>

<body>
    <div id="info">
        WASD bewegen â€“ Linksklick: SchieÃŸen â€“ Rechtsklick: Bauen<br>
        1: Wand â€¢ 2: Boden â€¢ 3: SÃ¤ule (Corn) â€¢ 4: Treppe
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>

    <script>
    let scene, camera, renderer;
    let controlsLocked = false;

    const keys = {};
    const speed = 0.1;

    let enemy;

    // Welche Bauart aktiv?
    let buildMode = 1;

    function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 1.7;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(3, 5, 2);
        scene.add(light);

        // Boden
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0x555555 })
        );
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Gegner
        enemy = new THREE.Mesh(
            new THREE.BoxGeometry(1,1,1),
            new THREE.MeshStandardMaterial({ color: 0xff0000 })
        );
        enemy.position.set(0,0.5,-5);
        scene.add(enemy);

        // Pointer Lock
        document.body.addEventListener("click", () => document.body.requestPointerLock());
        document.addEventListener("pointerlockchange", () => {
            controlsLocked = document.pointerLockElement === document.body;
        });

        document.addEventListener("mousemove", (e) => {
            if (!controlsLocked) return;
            camera.rotation.y -= e.movementX * 0.002;
            camera.rotation.x -= e.movementY * 0.002;
            camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
        });

        // Tasten
        document.addEventListener("keydown", (e) => {
            keys[e.key] = true;
            if (["1","2","3","4"].includes(e.key)) buildMode = Number(e.key);
        });
        document.addEventListener("keyup", (e) => keys[e.key] = false);

        // SchieÃŸen und Bauen
        document.addEventListener("mousedown", (e) => {
            if (e.button === 0) shoot();      // Links = schieÃŸen
            if (e.button === 2) build();      // Rechts = bauen
        });

        animate();
    }

    // ðŸ”« SchieÃŸen
    function shoot() {
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
        const hit = raycaster.intersectObject(enemy);

        if (hit.length > 0) {
            enemy.material.color.set(0x00ff00);
            setTimeout(() => enemy.material.color.set(0xff0000), 300);
        }
    }

    // ðŸ§± Objektbau je nach Buildmode
    function build() {
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);

        // Boden als Ziel
        const floor = scene.children.find(obj => obj.geometry && obj.geometry.type === "PlaneGeometry");
        const hits = raycaster.intersectObject(floor);

        if (hits.length === 0) return;

        // Position auf Grid runden
        let pos = hits[0].point;
        pos.x = Math.round(pos.x);
        pos.z = Math.round(pos.z);
        pos.y = 0;

        let mesh;

        if (buildMode === 1) { // Wand
            mesh = new THREE.Mesh(
                new THREE.BoxGeometry(1, 2, 0.2),
                new THREE.MeshStandardMaterial({ color: 0x8888ff })
            );
            mesh.position.set(pos.x, 1, pos.z);

        } else if (buildMode === 2) { // Bodenplatte
            mesh = new THREE.Mesh(
                new THREE.BoxGeometry(1, 0.1, 1),
                new THREE.MeshStandardMaterial({ color: 0x999999 })
            );
            mesh.position.set(pos.x, 0.05, pos.z);

        } else if (buildMode === 3) { // SÃ¤ule / Corn
            mesh = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 2, 16),
                new THREE.MeshStandardMaterial({ color: 0xffcc00 })
            );
            mesh.position.set(pos.x, 1, pos.z);

        } else if (buildMode === 4) { // Treppe
            mesh = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.MeshStandardMaterial({ color: 0x00aaff })
            );
            mesh.rotation.x = -Math.PI / 6; // leicht geneigt
            mesh.position.set(pos.x, 0.5, pos.z);
        }

        scene.add(mesh);
    }

    function movePlayer() {
        const forward = new THREE.Vector3(Math.sin(camera.rotation.y), 0, Math.cos(camera.rotation.y));
        const right = new THREE.Vector3().copy(forward).cross(new THREE.Vector3(0,1,0));

        if (keys["w"]) camera.position.addScaledVector(forward, -speed);
        if (keys["s"]) camera.position.addScaledVector(forward, speed);
        if (keys["a"]) camera.position.addScaledVector(right, -speed);
        if (keys["d"]) camera.position.addScaledVector(right, speed);
    }

    function animate() {
        requestAnimationFrame(animate);
        movePlayer();
        renderer.render(scene, camera);
    }

    init();
    </script>
</body>
</html>
